name: 'Configure Auth0 ACUL Screens'
description: 'Configures Auth0 Universal Login screens using the discovered assets'
inputs:
  working-directory:
    description: 'Working directory relative to repository root'
    required: true
    default: '.'
  cdn-url:
    description: 'Base URL of the CDN (without trailing slash)'
    required: true
  screens-json:
    description: 'JSON array of screens to configure'
    required: true
outputs:
  deployed_screens:
    description: 'Comma-separated list of successfully deployed screens'
    value: ${{ steps.configure.outputs.deployed_screens }}
  failed_screens:
    description: 'Comma-separated list of screens that failed to deploy'
    value: ${{ steps.configure.outputs.failed_screens }}
runs:
  using: 'composite'
  steps:
    - id: configure
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        CDN_URL: ${{ inputs.cdn-url }}
        SCREENS_JSON: ${{ inputs.screens-json }}
      run: |
        set -euo pipefail # Exit immediately if a command exits with non-zero status or unset variables are used

        #############################################
        # FUNCTIONS
        #############################################
        
        # Add asset to configuration JSON
        add_asset_to_json() {
          local asset_type="$1"  # "css" or "js"
          local asset_path="$2"
          local asset_name="$(basename "$asset_path")"
          local relative_path="${asset_path#dist/}"
          
          if [[ ! "$asset_name" == .* ]]; then # Skip hidden files
            local tag=""
            local attributes=""
            
            if [[ "$asset_type" == "css" ]]; then
              tag="link"
              attributes="rel: \"stylesheet\", href: \$url"
            else # JavaScript
              tag="script"
              attributes="src: \$url, type: \"module\""
            fi
            
            JSON_CONTENT=$(echo "$JSON_CONTENT" | jq --arg url "${CDN_BASE_URL}/${relative_path}" \
              ".head_tags += [{ tag: \"$tag\", attributes: { $attributes } }]") || \
              echo "::warning::Failed to add $asset_type file to JSON: $asset_name"
          fi
        }
        
        #############################################
        # INITIAL SETUP & VALIDATION
        #############################################
        
        echo "### Starting Auth0 screen configuration..."
        
        # Validate and normalize CDN URL
        CDN_BASE_URL="${CDN_URL}"
        if [ -z "$CDN_BASE_URL" ]; then
          echo "::error::CDN_URL input is not set."
          exit 1
        fi
        
        # Remove trailing slash if present
        if [[ "$CDN_BASE_URL" == */ ]]; then
           echo "::warning::CDN_URL ends with a slash. Removing it: $CDN_BASE_URL"
           CDN_BASE_URL=${CDN_BASE_URL%/}
        fi
        
        # Check for required dist directory
        if [ ! -d "dist" ] || [ ! -d "dist/assets" ]; then
          echo "::error::Required dist/assets directory does not exist!"
          exit 1
        fi

        SUCCESS_SCREENS=()
        FAILED_SCREENS=()

        #############################################
        # PROCESS SCREENS
        #############################################
        
        # Iterate over the JSON array of screen names
        while IFS= read -r screen; do
          echo "----------------------------------------------"
          echo "⚙️ Processing screen: $screen"

          # Set up paths for asset discovery
          SCREEN_ASSETS_DIR="dist/assets/$screen"
          SHARED_ASSETS_DIR="dist/assets/shared"
          ROOT_ASSETS_DIR="dist/assets"
          
          # Verify screen directory exists
          if [ ! -d "$SCREEN_ASSETS_DIR" ]; then
            echo "::error::Screen directory not found: $SCREEN_ASSETS_DIR"
            FAILED_SCREENS+=("$screen")
            continue
          fi
          
          # Create temporary settings file with proper cleanup handling
          SETTINGS_FILE=$(mktemp settings_XXXXXX.json)
          
          #############################################
          # ASSET DISCOVERY
          #############################################
          
          echo "🔍 Finding assets for screen: $screen"
          
          # Use a single find command to gather all assets and process them in memory
          ALL_ASSETS=$(find "dist/assets" -type f \( -name "*.js" -o -name "*.css" \) ! -name "*.map.js" 2>/dev/null | sort)
          
          # Initialize arrays for different asset types
          SCREEN_JS_FILES=()
          SHARED_JS_FILES=()
          ROOT_JS_FILES=()
          SCREEN_CSS_FILES=()
          SHARED_CSS_FILES=()
          
          # Process the results to categorize files
          while IFS= read -r file; do
            if [[ -z "$file" ]]; then
              continue
            fi
            
            # Determine file type and location
            if [[ "$file" == *".js" ]]; then
              # JavaScript files
              if [[ "$file" == "$SCREEN_ASSETS_DIR"* ]]; then
                SCREEN_JS_FILES+=("$file")
              elif [[ "$file" == "$SHARED_ASSETS_DIR"* ]]; then
                SHARED_JS_FILES+=("$file")
              elif [[ "$file" == "$ROOT_ASSETS_DIR/main."*".js" ]]; then
                ROOT_JS_FILES+=("$file")
              fi
            elif [[ "$file" == *".css" ]]; then
              # CSS files
              if [[ "$file" == "$SCREEN_ASSETS_DIR"* ]]; then
                SCREEN_CSS_FILES+=("$file")
              elif [[ "$file" == "$SHARED_ASSETS_DIR"* ]]; then
                SHARED_CSS_FILES+=("$file")
              fi
            fi
          done <<< "$ALL_ASSETS"
          
          # Check if we have at least one JS file for the screen
          if [ ${#SCREEN_JS_FILES[@]} -eq 0 ]; then
            echo "::error::No JavaScript files found for screen: $screen"
            FAILED_SCREENS+=("$screen")
            continue
          fi
          
          # Find main entry point for the screen
          SCREEN_ENTRY_FILE=""
          for file in "${SCREEN_JS_FILES[@]}"; do
            base_name=$(basename "$file")
            if [[ "$base_name" == "index.js" || "$base_name" == "main.js" ]]; then
              SCREEN_ENTRY_FILE="$file"
              break
            fi
          done
          
          # If no explicit entry file found, use the first JS file
          if [ -z "$SCREEN_ENTRY_FILE" ]; then
            SCREEN_ENTRY_FILE="${SCREEN_JS_FILES[0]}"
          fi
          
          #############################################
          # PRINT ASSET TABLE
          #############################################
          
          echo "📊 Assets being uploaded for screen: $screen"
          echo "------------------------------------------------------------"
          
          # Print Screen JS files with paths
          echo "📄 Screen JS Files:"
          if [ ${#SCREEN_JS_FILES[@]} -eq 0 ]; then
            echo "   (None)"
          else
            for file in "${SCREEN_JS_FILES[@]}"; do
              # Get relative path from dist
              rel_path="${file#dist/}"
              echo "   - $rel_path"
            done
          fi
          
          # Print Shared JS files with paths
          echo "📄 Shared JS Files:"
          if [ ${#SHARED_JS_FILES[@]} -eq 0 ]; then
            echo "   (None)"
          else
            for file in "${SHARED_JS_FILES[@]}"; do
              rel_path="${file#dist/}"
              echo "   - $rel_path"
            done
          fi
          
          # Print Root JS files with paths
          echo "📄 Root JS Files:"
          if [ ${#ROOT_JS_FILES[@]} -eq 0 ]; then
            echo "   (None)"
          else
            for file in "${ROOT_JS_FILES[@]}"; do
              rel_path="${file#dist/}"
              echo "   - $rel_path"
            done
          fi
          
          # Print Screen CSS files with paths
          echo "📄 Screen CSS Files:"
          if [ ${#SCREEN_CSS_FILES[@]} -eq 0 ]; then
            echo "   (None)"
          else
            for file in "${SCREEN_CSS_FILES[@]}"; do
              rel_path="${file#dist/}"
              echo "   - $rel_path"
            done
          fi
          
          # Print Shared CSS files with paths
          echo "📄 Shared CSS Files:"
          if [ ${#SHARED_CSS_FILES[@]} -eq 0 ]; then
            echo "   (None)"
          else
            for file in "${SHARED_CSS_FILES[@]}"; do
              rel_path="${file#dist/}"
              echo "   - $rel_path"
            done
          fi
          
          echo "------------------------------------------------------------"
          echo "🚀 Main entry point: $(basename "$SCREEN_ENTRY_FILE") (${SCREEN_ENTRY_FILE#dist/})"
          echo "📦 Total Files: $((${#SCREEN_JS_FILES[@]} + ${#SHARED_JS_FILES[@]} + ${#ROOT_JS_FILES[@]} + ${#SCREEN_CSS_FILES[@]} + ${#SHARED_CSS_FILES[@]}))"
          
          #############################################
          # GENERATE SETTINGS.JSON
          #############################################
          
          echo "📝 Building configuration for $screen"
          
          # Create context configuration array
          CONTEXT_CONFIG='["branding.settings", "branding.themes.default", "client.logo_uri", "client.description", "organization.display_name", "organization.branding", "screen.texts", "tenant.name", "tenant.friendly_name", "tenant.enabled_locales", "untrusted_data.submitted_form_data", "untrusted_data.authorization_params.ui_locales", "untrusted_data.authorization_params.login_hint", "untrusted_data.authorization_params.screen_hint"]'
          
          # Create base JSON structure
          JSON_CONTENT=$(jq -n \
            --arg base_href "${CDN_BASE_URL}/" \
            --argjson cfg "$CONTEXT_CONFIG" \
            '{ 
              rendering_mode: "advanced",
              context_configuration: $cfg,
              default_head_tags_disabled: false,
              head_tags: [
                { tag: "base", attributes: { href: $base_href } },
                { tag: "meta", attributes: { name: "viewport", content: "width=device-width, initial-scale=1" } }
              ]
            }')
          
          if [ $? -ne 0 ]; then
            echo "::error::Failed to create base JSON content"
            FAILED_SCREENS+=("$screen")
            continue
          fi

          # Add CSS files in order: Shared -> Screen-specific
          for css_file in "${SHARED_CSS_FILES[@]}" "${SCREEN_CSS_FILES[@]}"; do
            add_asset_to_json "css" "$css_file"
          done

          # Add JS files in order: Root main.js -> Shared files -> Screen JS (except entry) -> Entry point last
          for js_file in "${ROOT_JS_FILES[@]}" "${SHARED_JS_FILES[@]}"; do
            add_asset_to_json "js" "$js_file"
          done
          
          # Add screen JS files (excluding entry point)
          for js_file in "${SCREEN_JS_FILES[@]}"; do
            if [ "$js_file" != "$SCREEN_ENTRY_FILE" ]; then
              add_asset_to_json "js" "$js_file"
            fi
          done
          
          # Add entry point last - critical for screen functionality
          relative_path="${SCREEN_ENTRY_FILE#dist/}"
          js_basename=$(basename "$SCREEN_ENTRY_FILE")
          JSON_CONTENT=$(echo "$JSON_CONTENT" | jq --arg url "${CDN_BASE_URL}/${relative_path}" \
            '.head_tags += [{ tag: "script", attributes: { src: $url, type: "module" } }]')
          
          if [ $? -ne 0 ]; then
            echo "::error::Failed to add critical entry point file to JSON: $js_basename"
            FAILED_SCREENS+=("$screen")
            continue
          fi

          # Write JSON to temp file
          echo "$JSON_CONTENT" > "$SETTINGS_FILE" || {
            echo "::error::Failed to write settings file"
            FAILED_SCREENS+=("$screen")
            continue
          }

          #############################################
          # CONFIGURE AUTH0 SCREEN
          #############################################
          
          echo "🔄 Configuring Auth0 prompt: $screen"
          
          # Verify auth0 CLI is available
          if ! command -v auth0 &> /dev/null; then
            echo "::error::auth0 CLI not found"
            FAILED_SCREENS+=("$screen")
            continue
          fi
          
          # Run the auth0 command to configure the screen
          if OUTPUT=$(auth0 ul customize \
            --rendering-mode advanced \
            --prompt "$screen" \
            --screen "$screen" \
            --settings-file "$SETTINGS_FILE" 2>&1); then
            echo "✅ Successfully configured: $screen"
            SUCCESS_SCREENS+=("$screen")
          else
            exit_code=$?
            echo "::error::Failed to configure prompt: $screen (Exit Code: $exit_code)"
            
            # Special handling for custom domain errors
            if [[ "$OUTPUT" == *"requires at least one custom domain"* ]]; then
              echo "⚠️ Auth0 tenant requires a custom domain (tenant configuration issue)"
            fi
            
            FAILED_SCREENS+=("$screen")
          fi
          
          # Clean up temp file
          echo "Cleaning up temp file for screen: $screen"
          rm -f "$SETTINGS_FILE"
          
        done < <(echo "$SCREENS_JSON" | jq -r '.[]' || echo "Failed to parse screens JSON")

        #############################################
        # FINAL REPORTING
        #############################################
        
        echo "----------------------------------------------"
        echo "### Configuration Summary"
        
        # Create comma-separated lists using IFS (more standard approach)
        # Handle empty arrays to display "None" when no screens were processed
        if [ ${#SUCCESS_SCREENS[@]} -eq 0 ]; then
          deployed_screens_output="None"
        else
          deployed_screens_output=$(IFS=,; echo "${SUCCESS_SCREENS[*]}")
        fi
        
        if [ ${#FAILED_SCREENS[@]} -eq 0 ]; then
          failed_screens_output="None"
        else
          failed_screens_output=$(IFS=,; echo "${FAILED_SCREENS[*]}")
        fi

        # Simple deployment summary without showing sensitive CDN URL
        echo "📈 Auth0 ACUL Screens Deployment Summary"
        echo "┌────────────────┬─────────┐"
        echo "│ Screen         │ Status  │"
        echo "├────────────────┼─────────┤"
        
        for screen in $(echo "$SCREENS_JSON" | jq -r '.[]'); do
          if [[ " ${SUCCESS_SCREENS[*]} " =~ " ${screen} " ]]; then
            status="✅ Success"
          else
            status="❌ Failed"
          fi
          printf "│ %-14s │ %-7s │\n" "$screen" "$status"
        done
        
        echo "└────────────────┴─────────┘"
        
        echo "- Successfully configured: $deployed_screens_output"
        echo "- Failed to configure: $failed_screens_output"

        # Set job outputs
        echo "deployed_screens=${deployed_screens_output}" >> $GITHUB_OUTPUT
        echo "failed_screens=${failed_screens_output}" >> $GITHUB_OUTPUT

        # Final status check
        if [ ${#SUCCESS_SCREENS[@]} -eq 0 ] && [ ${#FAILED_SCREENS[@]} -gt 0 ]; then
          echo "::error::All screens failed to configure. Aborting with error status."
          exit 1
        elif [ ${#FAILED_SCREENS[@]} -ne 0 ]; then
          echo "::warning::Some screens failed to configure but at least one was successful."
        else
          echo "✅ All screens configured successfully."
        fi