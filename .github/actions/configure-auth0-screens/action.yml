name: 'Configure Auth0 ACUL Screens'
description: 'Configures Auth0 Universal Login screens using the discovered assets'
inputs:
  working-directory:
    description: 'Working directory relative to repository root'
    required: true
    default: '.'
  cdn-url:
    description: 'Base URL of the CDN (without trailing slash)'
    required: true
  screens-json:
    description: 'JSON array of screens to configure'
    required: true
outputs:
  deployed_screens:
    description: 'Comma-separated list of successfully deployed screens'
    value: ${{ steps.configure.outputs.deployed_screens }}
  failed_screens:
    description: 'Comma-separated list of screens that failed to deploy'
    value: ${{ steps.configure.outputs.failed_screens }}
runs:
  using: 'composite'
  steps:
    - id: configure
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        CDN_URL: ${{ inputs.cdn-url }}
        SCREENS_JSON: ${{ inputs.screens-json }}
      run: |
        set -eo pipefail # Exit immediately if a command exits with non-zero status

        echo "Starting Auth0 screen configuration..."
        CDN_BASE_URL="${CDN_URL}"
        if [ -z "$CDN_BASE_URL" ]; then
          echo "::error::CDN_URL input is not set."
          exit 1
        fi
        # Ensure CDN_URL does not have a trailing slash
        if [[ "$CDN_BASE_URL" == */ ]]; then
           echo "::warning::CDN_URL ends with a slash. Removing it: $CDN_BASE_URL"
           CDN_BASE_URL=${CDN_BASE_URL%/}
        fi

        echo "CDN Base URL: $CDN_BASE_URL"
        echo "Screens to configure (JSON): $SCREENS_JSON"

        # Debug: Verify the working directory
        echo "Working directory: $(pwd)"
        echo "Contents of working directory:"
        ls -la
        
        # Debug: Check for the dist directory
        if [ -d "dist" ]; then
          echo "‚úÖ Dist directory exists"
          echo "Contents of dist directory:"
          ls -la dist
          
          if [ -d "dist/assets" ]; then
            echo "‚úÖ Dist/assets directory exists"
            echo "Contents of dist/assets directory:"
            ls -la dist/assets
          else
            echo "‚ùå ERROR: dist/assets directory does not exist"
            exit 1
          fi
        else
          echo "‚ùå ERROR: dist directory does not exist"
          exit 1
        fi

        SUCCESS_SCREENS=()
        FAILED_SCREENS=()

        # Iterate over the JSON array of screen names
        while IFS= read -r screen; do
          echo "--------------------------------------------------"
          echo "Processing screen: $screen"

          # --- Asset Discovery for the screen ---
          SCREEN_ASSETS_DIR="dist/assets/$screen"
          SHARED_ASSETS_DIR="dist/assets/shared"
          ROOT_ASSETS_DIR="dist/assets"
          
          # Check if screen directory exists
          if [ ! -d "$SCREEN_ASSETS_DIR" ]; then
            echo "::error::Screen directory not found: $SCREEN_ASSETS_DIR"
            echo "Available screens in assets directory:"
            ls -la "dist/assets"
            FAILED_SCREENS+=("$screen")
            continue
          fi
          
          echo "üîç Asset discovery for screen: $screen"
          echo "  - Screen directory: $SCREEN_ASSETS_DIR"
          echo "  - Shared directory: $SHARED_ASSETS_DIR"
          echo "  - Root assets directory: $ROOT_ASSETS_DIR"
          
          # Temp file for settings
          SETTINGS_FILE=$(mktemp settings_XXXXXX.json)
          trap 'echo "Cleaning up temporary settings file: $SETTINGS_FILE"; rm -f "$SETTINGS_FILE"' EXIT
          
          # Find JS and CSS files for the screen
          SCREEN_JS_FILES=($(find "$SCREEN_ASSETS_DIR" -type f -name "*.js" ! -name "*.map.js" | sort))
          SHARED_JS_FILES=($(find "$SHARED_ASSETS_DIR" -type f -name "*.js" ! -name "*.map.js" 2>/dev/null | sort))
          ROOT_JS_FILES=($(find "$ROOT_ASSETS_DIR" -maxdepth 1 -type f -name "main.*.js" ! -name "*.map.js" 2>/dev/null | sort))
          SCREEN_CSS_FILES=($(find "$SCREEN_ASSETS_DIR" -type f -name "*.css" | sort))
          SHARED_CSS_FILES=($(find "$SHARED_ASSETS_DIR" -type f -name "*.css" 2>/dev/null | sort))
          
          # Check if we have at least one JS file for the screen
          if [ ${#SCREEN_JS_FILES[@]} -eq 0 ]; then
            echo "::error::No JavaScript files found for screen: $screen"
            echo "Contents of screen directory:"
            ls -la "$SCREEN_ASSETS_DIR" || echo "Failed to list directory"
            FAILED_SCREENS+=("$screen")
            continue
          fi
          
          # Find main entry point for the screen (usually named index.js or main.js)
          SCREEN_ENTRY_FILE=""
          for file in "${SCREEN_JS_FILES[@]}"; do
            base_name=$(basename "$file")
            if [[ "$base_name" == "index.js" || "$base_name" == "main.js" ]]; then
              SCREEN_ENTRY_FILE="$file"
              break
            fi
          done
          
          # If no entry file found, use the first JS file
          if [ -z "$SCREEN_ENTRY_FILE" ]; then
            SCREEN_ENTRY_FILE="${SCREEN_JS_FILES[0]}"
            echo "‚ö†Ô∏è No explicit entry point found, using: $(basename "$SCREEN_ENTRY_FILE")"
          else
            echo "‚úÖ Found entry point: $(basename "$SCREEN_ENTRY_FILE")"
          fi
          
          # Asset Summary
          echo "üìã Asset Summary for $screen:"
          echo "- Screen JS Files: ${#SCREEN_JS_FILES[@]}"
          echo "- Shared JS Files: ${#SHARED_JS_FILES[@]}"
          echo "- Root JS Files: ${#ROOT_JS_FILES[@]}"
          echo "- Screen CSS Files: ${#SCREEN_CSS_FILES[@]}"
          echo "- Shared CSS Files: ${#SHARED_CSS_FILES[@]}"
          echo "- Entry Point: $(basename "$SCREEN_ENTRY_FILE")"

          # --- Generate settings.json --- 
          echo "üîß Generating settings.json for $screen..."
          
          # Create context configuration array
          CONTEXT_CONFIG='["branding.settings", "branding.themes.default", "client.logo_uri", "client.description", "organization.display_name", "organization.branding", "screen.texts", "tenant.name", "tenant.friendly_name", "tenant.enabled_locales", "untrusted_data.submitted_form_data", "untrusted_data.authorization_params.ui_locales", "untrusted_data.authorization_params.login_hint", "untrusted_data.authorization_params.screen_hint"]'
          
          # Create base JSON structure
          JSON_CONTENT=$(jq -n \
            --arg base_href "${CDN_BASE_URL}/" \
            --argjson cfg "$CONTEXT_CONFIG" \
            '{ 
              rendering_mode: "advanced",
              context_configuration: $cfg,
              default_head_tags_disabled: false,
              head_tags: [
                { tag: "base", attributes: { href: $base_href } },
                { tag: "meta", attributes: { name: "viewport", content: "width=device-width, initial-scale=1" } }
              ]
            }')
          
          if [ $? -ne 0 ]; then
            echo "::error::Failed to create base JSON content"
            FAILED_SCREENS+=("$screen")
            continue
          fi

          # Add CSS files in order: Shared -> Screen-specific
          echo "Adding CSS files to configuration..."
          
          # Shared CSS files (common styles)
          for css_file in "${SHARED_CSS_FILES[@]}"; do
            css_basename=$(basename "$css_file")
            if [[ ! "$css_basename" =~ ^[^a-zA-Z0-9] ]]; then
              relative_path="${css_file#dist/}"
              echo "  - Adding shared CSS: $css_basename"
              JSON_CONTENT=$(echo "$JSON_CONTENT" | jq --arg url "${CDN_BASE_URL}/${relative_path}" '.head_tags += [{ tag: "link", attributes: { rel: "stylesheet", href: $url } }]')
              if [ $? -ne 0 ]; then
                echo "::warning::Failed to add CSS file to JSON: $css_basename"
              fi
            fi
          done
          
          # Screen-specific CSS files
          for css_file in "${SCREEN_CSS_FILES[@]}"; do
            css_basename=$(basename "$css_file")
            if [[ ! "$css_basename" =~ ^[^a-zA-Z0-9] ]]; then
              relative_path="${css_file#dist/}"
              echo "  - Adding screen CSS: $css_basename"
              JSON_CONTENT=$(echo "$JSON_CONTENT" | jq --arg url "${CDN_BASE_URL}/${relative_path}" '.head_tags += [{ tag: "link", attributes: { rel: "stylesheet", href: $url } }]')
              if [ $? -ne 0 ]; then
                echo "::warning::Failed to add CSS file to JSON: $css_basename"
              fi
            fi
          done

          # Add JS files in proper order: Root main.js, Shared files, then screen-specific entry
          echo "Adding JavaScript files to configuration..."
          
          # Add main.js from root assets directory first (if exists)
          for js_file in "${ROOT_JS_FILES[@]}"; do
            js_basename=$(basename "$js_file")
            if [[ ! "$js_basename" =~ ^[^a-zA-Z0-9] ]]; then
              relative_path="${js_file#dist/}"
              echo "  - Adding root main JS: $js_basename"
              JSON_CONTENT=$(echo "$JSON_CONTENT" | jq --arg url "${CDN_BASE_URL}/${relative_path}" '.head_tags += [{ tag: "script", attributes: { src: $url, type: "module" } }]')
              if [ $? -ne 0 ]; then
                echo "::warning::Failed to add root main JS file to JSON: $js_basename"
              fi
            fi
          done
          
          # Shared JS files (framework, libraries, etc.)
          for js_file in "${SHARED_JS_FILES[@]}"; do
            js_basename=$(basename "$js_file")
            if [[ ! "$js_basename" =~ ^[^a-zA-Z0-9] ]]; then
              relative_path="${js_file#dist/}"
              echo "  - Adding shared JS: $js_basename"
              JSON_CONTENT=$(echo "$JSON_CONTENT" | jq --arg url "${CDN_BASE_URL}/${relative_path}" '.head_tags += [{ tag: "script", attributes: { src: $url, type: "module" } }]')
              if [ $? -ne 0 ]; then
                echo "::warning::Failed to add JS file to JSON: $js_basename"
              fi
            fi
          done
          
          # Screen JS files (excluding the entry point, which comes last)
          for js_file in "${SCREEN_JS_FILES[@]}"; do
            if [ "$js_file" != "$SCREEN_ENTRY_FILE" ]; then
              js_basename=$(basename "$js_file")
              if [[ ! "$js_basename" =~ ^[^a-zA-Z0-9] ]]; then
                relative_path="${js_file#dist/}"
                echo "  - Adding screen JS: $js_basename"
                JSON_CONTENT=$(echo "$JSON_CONTENT" | jq --arg url "${CDN_BASE_URL}/${relative_path}" '.head_tags += [{ tag: "script", attributes: { src: $url, type: "module" } }]')
                if [ $? -ne 0 ]; then
                  echo "::warning::Failed to add JS file to JSON: $js_basename"
                fi
              fi
            fi
          done
          
          # Add the screen entry point last
          relative_path="${SCREEN_ENTRY_FILE#dist/}"
          js_basename=$(basename "$SCREEN_ENTRY_FILE")
          echo "  - Adding screen entry point: $js_basename"
          JSON_CONTENT=$(echo "$JSON_CONTENT" | jq --arg url "${CDN_BASE_URL}/${relative_path}" '.head_tags += [{ tag: "script", attributes: { src: $url, type: "module" } }]')
          if [ $? -ne 0 ]; then
            echo "::warning::Failed to add entry point to JSON: $js_basename"
          fi

          # Write the final JSON to the temp file
          echo "$JSON_CONTENT" > "$SETTINGS_FILE"
          if [ $? -ne 0 ]; then
            echo "::error::Failed to write settings file"
            FAILED_SCREENS+=("$screen")
            continue
          fi

          echo "Generated settings.json content:"
          jq . "$SETTINGS_FILE" || echo "Failed to display settings file"

          # --- Configure Auth0 Screen ---
          echo "üîÑ Attempting to configure Auth0 prompt: $screen"
          
          # Verify auth0 CLI is available
          if ! command -v auth0 &> /dev/null; then
            echo "::error::auth0 CLI not found. Make sure it is installed and in PATH."
            FAILED_SCREENS+=("$screen")
            continue
          fi
          
          # Run the command and capture output and exit code separately
          if OUTPUT=$(auth0 ul customize \
            --rendering-mode advanced \
            --prompt "$screen" \
            --screen "$screen" \
            --settings-file "$SETTINGS_FILE" 2>&1); then
            echo "‚úÖ Successfully configured prompt: $screen"
            SUCCESS_SCREENS+=("$screen")
          else
            exit_code=$?
            echo "::error::Failed to configure prompt: $screen (Exit Code: $exit_code). Output below:"
            echo "$OUTPUT" # Print the captured output on error
            
            # Check if the error is about custom domain (which is a tenant configuration issue, not a script issue)
            if [[ "$OUTPUT" == *"requires at least one custom domain"* ]]; then
              echo "‚ö†Ô∏è NOTE: This is a tenant configuration issue. The Auth0 tenant needs a custom domain."
              echo "‚ö†Ô∏è To fix this, use 'auth0 domains create' to create a custom domain and 'auth0 domains verify' to verify it."
            fi
            
            FAILED_SCREENS+=("$screen")
            # Continue to next screen
          fi
          
          # Clean up the settings file for this screen
          rm -f "$SETTINGS_FILE"
          
        done < <(echo "$SCREENS_JSON" | jq -r '.[]' || echo "Failed to parse screens JSON") # End of screen loop

        # --- Final Reporting ---
        echo "--------------------------------------------------"
        echo "Configuration Summary:"
        # Join arrays with commas for output, handle empty arrays gracefully
        printf -v deployed_screens_output '%s,' "${SUCCESS_SCREENS[@]}"
        printf -v failed_screens_output '%s,' "${FAILED_SCREENS[@]}"
        # Remove trailing comma if list is not empty
        deployed_screens_output=${deployed_screens_output%,}
        failed_screens_output=${failed_screens_output%,}

        echo "Successfully configured: ${deployed_screens_output:-None}"
        echo "Failed to configure: ${failed_screens_output:-None}"

        # Set job outputs
        echo "deployed_screens=${deployed_screens_output}" >> $GITHUB_OUTPUT
        echo "failed_screens=${failed_screens_output}" >> $GITHUB_OUTPUT

        # Check if all screens failed
        if [ ${#SUCCESS_SCREENS[@]} -eq 0 ] && [ ${#FAILED_SCREENS[@]} -gt 0 ]; then
          echo "::error::All screens failed to configure. Aborting with error status."
          exit 1
        fi

        # Check if some screens failed
        if [ ${#FAILED_SCREENS[@]} -ne 0 ]; then
          echo "::warning::Some screens failed to configure: ${failed_screens_output}"
          echo "But at least one screen was successful. Continuing with success status."
          
          # Special handling for custom domain errors
          if [[ "$OUTPUT" == *"requires at least one custom domain"* ]]; then
            echo "::warning::Auth0 tenant requires a custom domain. This is not a script issue."
            echo "Successfully validated screen assets. Skipping actual configuration due to tenant limitations."
          fi
        else
          echo "‚úÖ All discovered screens configured successfully."
        fi